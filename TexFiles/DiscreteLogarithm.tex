\section{Discrete Log}
\begin{frame}
	\frametitle{Discrete Logarithm - Pedersen commitment scheme}
	\framesubtitle{Requirements and Definitions}
	Prerequisites: Bob needs to setup the environtment for alice, by 
	\begin{enumerate}
		\item choosing a large prime number p
		\item choosing a smaller prime number $q \in \{1..p| q\div (p-1) = 0\}$
		\item choosing $g,v \in G_q \neq 1$
		\item sending Alice $p,q,g,v$ 
	\end{enumerate}

	Now Alice can \textit{build} the exact same group and subgroup like Bob. ~\newline
	This is similiar to sending the hash-function.  
\end{frame}

\begin{frame}
	\frametitle{Implementation}
	\begin{itemize}
		\item Alice requests $p,q,g,v$ from Bob. Alice check that $q,p$ are primes, q divides p-1, that g and v are valid elements. 
		\item Alice chooses her message $m \in \{1..p\}$ and a random number $r \in \{1..q-1\}$
		\item Alice sends $c = g^rv^m$ to Bob \textbf{(commit)}
		\item Bob keeps $<Alice,c,<p,q,g,v>>$
		\item Alice can reveal herself by sending $r,m$ to Bob. Bob checks $c = g^rv^m$
	\end{itemize}
\end{frame}

\begin{frame}
	\frametitle{Benefits}
	Major:
	\begin{itemize}
		\item Commitments always contain random parts
		\item No collision possible (unlike Hashfunctions)	
	\end{itemize}
	Minor:
	\begin{itemize}
		\item tupels are smaller to store than hashes
		\item $p,q,g,v$ are easily changed/renewed (you could not renew hashfunctions)
	\end{itemize}
\end{frame}